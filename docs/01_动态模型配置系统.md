# 动态模型配置系统详解

## 概述

本文档详细介绍了基于JManus设计模式实现的动态模型配置系统。该系统旨在解决传统Spring AI配置方式中需要在配置文件中硬编码API key和模型名的问题，通过数据库驱动的配置管理，实现了更灵活、安全的AI模型使用方式。

## 核心设计思路

### 1. 传统配置方式的局限

传统的Spring AI配置方式强制要求在`application.yml`中配置API key和模型名：

```yaml
spring:
  ai:
    openai:
      api-key: your-api-key
      chat:
        options:
          model: gpt-3.5-turbo
```

这种方式存在以下问题：
- 硬编码敏感信息，存在安全风险
- 配置固定，无法在运行时动态切换模型
- 不支持多模型管理

### 2. 解决方案

通过以下方式实现动态模型配置：
- 排除Spring AI自动配置
- 将模型配置存储在数据库中
- 运行时动态创建ChatClient
- 支持模型切换和缓存机制

## 系统架构

### 1. 数据层

#### DynamicModelEntity（模型配置实体）
存储模型的所有配置信息：

```java
@Entity
@Table(name = "dynamic_models")
public class DynamicModelEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String baseUrl;        // API基础URL
    
    @Column(nullable = false)
    private String apiKey;         // API密钥
    
    @Convert(converter = MapToStringConverter.class)
    @Column(columnDefinition = "VARCHAR(2048)")
    private Map<String, String> headers; // 自定义HTTP头
    
    @Column(nullable = false)
    private String modelName;      // 模型名称
    
    @Column(nullable = false, length = 1000)
    private String modelDescription; // 模型描述
    
    @Column(nullable = false)
    private String type;           // 模型类型
    
    @Column(nullable = false, columnDefinition = "boolean default false")
    private boolean isDefault;     // 是否为默认模型
    
    @Column
    private Double temperature;    // 温度参数
    
    @Column
    private Double topP;          // Top-P参数
    
    @Column
    private String completionsPath; // 完成路径
}
```

#### MapToStringConverter（类型转换器）
用于将Map类型的数据存储为字符串格式：

```java
@Converter
public class MapToStringConverter implements AttributeConverter<Map<String, String>, String> {
    // 实现Map与String之间的相互转换
}
```

### 2. 数据访问层

#### DynamicModelRepository（数据访问接口）
提供对模型配置数据的CRUD操作：

```java
@Repository
public interface DynamicModelRepository extends JpaRepository<DynamicModelEntity, Long> {
    DynamicModelEntity findByModelName(String modelName);
    DynamicModelEntity findByIsDefaultTrue();
}
```

### 3. 业务逻辑层

#### LlmService（核心服务）
负责创建和管理ChatClient：

```java
@Service
public class LlmService {
    // 缓存ChatClient实例
    private final Map<String, ChatClient> chatClientCache = new ConcurrentHashMap<>();
    
    // 获取默认ChatClient
    public ChatClient getDefaultChatClient() { ... }
    
    // 根据模型名获取ChatClient
    public ChatClient getChatClient(String modelName) { ... }
    
    // 刷新默认模型缓存
    public void refreshDefaultModelCache() { ... }
    
    // 清空ChatClient缓存
    public void clearAllChatClientCache() { ... }
}
```

### 4. 控制层

#### ModelController（API控制器）
提供REST API接口：

```java
@RestController
@RequestMapping("/api/models")
public class ModelController {
    @GetMapping
    public List<DynamicModelEntity> getAllModels() { ... }
    
    @PostMapping
    public DynamicModelEntity createModel(@RequestBody DynamicModelEntity model) { ... }
    
    @PutMapping("/{id}/default")
    public String setDefaultModel(@PathVariable Long id) { ... }
    
    @PostMapping("/chat")
    public String chat(@RequestParam String modelName, @RequestParam String message) { ... }
}
```

## 实现细节

### 1. 排除自动配置

在`application.yml`中排除Spring AI自动配置：

```yaml
spring:
  ai:
    autoconfigure:
      exclude:
        - org.springframework.ai.autoconfigure.openai.OpenAiAutoConfiguration
        - org.springframework.ai.model.chat.client.autoconfigure.ChatClientAutoConfiguration
```

或者在Java配置中：

```java
@Configuration
@ImportAutoConfiguration(exclude = {
    org.springframework.ai.autoconfigure.openai.OpenAiAutoConfiguration.class,
    org.springframework.ai.model.chat.client.autoconfigure.ChatClientAutoConfiguration.class
})
public class AiConfig {
}
```

### 2. 动态创建ChatClient

```java
private ChatModel createChatModel(DynamicModelEntity dynamicModelEntity, OpenAiChatOptions defaultOptions) {
    OpenAiChatOptions.Builder optionsBuilder = OpenAiChatOptions.builder()
        .withModel(dynamicModelEntity.getModelName());
    
    if (dynamicModelEntity.getTemperature() != null) {
        optionsBuilder.withTemperature(dynamicModelEntity.getTemperature().floatValue());
    }
    if (dynamicModelEntity.getTopP() != null) {
        optionsBuilder.withTopP(dynamicModelEntity.getTopP().floatValue());
    }
    
    var openAiApi = openAiApi(restClientBuilderProvider.getIfAvailable(RestClient::builder),
            webClientBuilderProvider.getIfAvailable(WebClient::builder), dynamicModelEntity);
    
    var chatModel = new OpenAiChatModel(
        openAiApi,
        optionsBuilder.build()
    );

    return chatModel;
}
```

### 3. 缓存机制

实现多级缓存策略：
- 模型配置缓存：缓存从数据库获取的模型配置
- ChatClient缓存：缓存创建的ChatClient实例
- 懒加载机制：按需加载模型配置

## 优势

### 1. 安全性
- API key存储在数据库中，不在配置文件中暴露
- 支持加密存储敏感信息

### 2. 灵活性
- 支持运行时动态切换模型
- 支持多模型管理
- 支持模型参数动态调整

### 3. 可扩展性
- 支持多种AI模型提供商
- 支持自定义模型配置
- 支持配置热更新

## 与JManus的相似性

本实现借鉴了JManus项目的以下设计思想：

1. **数据库驱动配置**：JManus同样使用数据库存储模型配置信息
2. **排除自动配置**：避免Spring AI强制要求配置文件中的API key
3. **动态客户端创建**：根据运行时配置动态创建AI客户端
4. **缓存管理**：使用缓存提高性能
5. **模型切换支持**：支持运行时切换默认模型

## 扩展建议

1. **加密存储**：对数据库中的API key进行加密存储
2. **模型验证**：增加模型配置有效性验证
3. **审计日志**：记录模型使用情况
4. **权限管理**：对模型配置进行权限控制
5. **监控指标**：添加模型使用性能指标

## 总结

通过这种动态模型配置系统，我们实现了：
- 不需要在配置文件中硬编码敏感信息
- 运行时动态管理和切换AI模型
- 更好的安全性和灵活性
- 与JManus设计思路一致的架构

这种设计特别适合需要灵活管理多个AI模型的企业级应用场景。